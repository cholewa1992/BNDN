\documentclass[../report.tex]{subfiles}


\begin{document}


\section{Erroneous states}

In trying to prevent implementation errors from leading to runtime errors, Code Contracts\footnote{Microsoft Research plug-in for .NET} have been implemented for variable checking in the business logic on our back-end.

Code contracts can be used with three different syntaxes

\begin{itemize}
\item \textbf{Legacy if-then-throw:}
\subitem if(argument <= 0) throw new ArgumentException();  
\subitem Contract.EndContractBlock();

\item \textbf{Contract library:}
\subitem Contract.Requires(argument > 0);

\item \textbf{Contract library with custom exceptions:}
\subitem Contract.Requires<ArgumentException>(argument > 0);
\end{itemize}

Overall we have chosen to use Code Contracts because of Readability and control.

We have chosen not to use the if-then-throw syntax because of readability. This approach will most likely be chosen when expanding on a system already using the if-then-throw syntax, but since we are developing from a clean slate, we have no schematic consistency requirements in form of legacy if-then-throw clauses.

Another benefit of using the Contract library is that it is explicit from the method whether we are checking a pre- or postcondition.

When a contract with no custom exception specified is broken, a ContractException is thrown. This is why one also has the option for specifying an exception.

We have chosen to use custom exceptions because we have to expose these errors as faults in our services. Without custom exceptions it would always be a ContractException, and then we would have to check the exception message to distinguish.

Choosing Code contracts for the control element comes down to building assemblies. With Code contracts one can choose to what degree variable checks are build with assemblies.

Since we are developing an open API, we want to check variables parsed to us, and so our assemblies are compiled with full runtime checking. This means that all our team needs Code Contracts installed in order to work on our source code. Ultimately this was the only hindrance we faced in using Code Contracts.




\end{document}